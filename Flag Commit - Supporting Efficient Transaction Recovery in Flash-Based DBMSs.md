[TOC]

---

#  基于闪存的数据库管理系统的高效事务恢复提交协议：Flag Commit

---

## Abstract

- 研究在SLC闪存中运行的DBMSs如何高效得完成事务的恢复。
- 在传统的shadow-paging方式的基础上，提出了新的提交协议flagcommit，能利用flash的快速随机访问、异地更新、局部页编程的特性。
- 利用事务提交标志链内嵌事务状态到闪存页中以减少写log记录的需求。
- 设计了两种恢复协议：commit-based flag commit（CFC）和abort-based flag commit（AFC）。满足不同的性能需求。
- 基于TPC-C标准的测试，评估CFC和AFC性能优于已有的恢复协议。

---

## Introduction

- Flash以其优良特性备受关注，本文研究在事务恢复中如何利用SLC的优点以提高基于闪存的DBMSs的性能。
- 事务恢复作用：保证原子性（一系列动作要么全部完成，要么都不完成）和持久性（提交的写得到保证）。事务恢复已有实现：WAL和Shadow Paging。WAL：以日志的方式持久化旧数据，再原地更新，写操作太频繁。SP：以磁盘上的shadow-page对数据页做异地更新，系统维护一张page ID到disk address的映射表，性能问题使它在磁盘中表现不佳，但是在闪存中确是可取的。
- 循环提交（cyclic commit）是一种根据影子页提出的提交机制。为提交的事务的每一个页维护一个循环链表，通过检查这个表的存在与否确定该事务是否提交。根据这一思想产生两种提交协议：SCC（simple cyclic commit）& BPCC（back pointer cyclic commit）。但是应用中存在一些问题，如高并发等。
- 本文提出一种新的基于影子页的提交机制flagcommit，利用闪存页局部可编程特性保持对事务状态的追踪，在每个shadow page中存储事务的状态标志。基于这种思想本文提出两种提交协议：CFC（commit-based flag commit）& AFC（abort-based flag commit）。它们适用与不同负载、具有不同性能。
- 本文主要工作：
  - 首次提出基于闪存的DBMSs快速高效事务恢复机制，flagcommit。
  - 根据flagcommit提出两种事务恢复协议，以及每个协议针对事务处理、垃圾回收、恢复的算法。
  - 扩展上文提出的两种协议对通用DBMS的支持。
  - 对本文提出的协议做性能评估，结果显示性能提升量巨大。

---

## Background

本节主要内容：*研究背景、闪存特性、闪存转换层FTL*

### 闪存特性

* 物理特性：片－块（128k+4k）－页（2k+64byte），块为擦除单位，页为读写单位
* IO特性：高效随机访问、先块擦后页写、块擦除次数有限（故在FTL中实现异地更新）

### 闪存转换层FTL

- FTL的核心是在内存中维护一张逻辑地址到物理地址的映射表，闪存页的OOB区存储其逻辑地址，用以在启动时在FTL建立正向的映射表。
- 通过维护映射表实现异地更新。
- 维护一张空间表，拥有垃圾回收模块回收废弃的页。回收页：触发垃圾回收（如根据块中的废弃页数量）- 将块中有效页复制到空闲块中 - 擦除块 - 将该块挂接到空闲块表中。
- 利用分散写和擦除实现闪存的磨损均衡，以延长使用寿命。



ps：并没有像Introduction介绍的那样在本节介绍研究背景

---

## Basic Flag Commit Protocols

为了系统恢复时确定事务该重做还是丢弃，需要保持对数据库的更新状态以及事务状态的跟踪。shadow paging利用日志进行异地更新以记录事务状态。本文提出的flagcommit基于shadowpaging的方法和循环提交的思想。

flagcommit在每个影子页的OOB区存储一个指向属于同一个事务的之前一个flash page的指针，同时存储状态标志、页版本、事务ID，通过这个链可以找到属于该事务的所有页，通过页中的状态标志可以检查该事务的提交状态。

### Commit-Based Flag Commit

CFC协议采用标志指示已提交的事务，默认情况下页的事务标志置FALSE，当事务提交时，属于该事务的页链的最后一个页的事务标识被更新为TRUE。

> - CFC中当且仅当影子页中至少有一个页的事务标志为TRUE时，该事务为已提交事务。
> - 若更新该页的事务已提交，那么该页就是已提交页。

#### In-memory Tables

- 事务表Transaction Table：该表只维护正在执行或中止的事务。表属性包括事务ID、状态、页数、最后页指针。
- 脏页表Dirty Page Table：保持对正在执行的事务更新造成的每个脏页的物理地址的跟踪。
- 地址映射表Direct Mapping Table：维护逻辑地址到物理地址的映射关系。

#### Normal Processing

- 更新页：
  - 事务T提出要更新逻辑页P
  - FlashDisk分配影子页P'，并在该影子页的OOB中初始化LBA、Ver、Link、XID、CommitFlag。
  - 更新事务表Transaction Table，NPage加一、LastPage指向P'。
  - P页添加入脏页表Dirty Table。
  - 更新地址映射表。
- 提交事务：
  - 事务提交请求。
  - 在事务表中找到该事务表项，获得其最后一个影子页，更新其状态标志为TRUE。
  - 将该事务从事务表中删除。
  - 该事务更新的页从脏页表中删除，且其指向的上一个页标记为废弃页。（PS：事务T要更新页P，实际更新的是影子页P'，此时脏页表记录的是事务ID-T、LBA-P'、LastLBA-P，一旦事务T提交，影子页P'“扶正”，原页P标记为废弃）
- 事务中止：
  - 事务T中止
  - 撤销T造成的更新，将其更新的页P'标记为废弃页
  - 检查脏页表，找到P'的上一个页P，通过修改映射表恢复P页

#### Garbage Collection

垃圾回收通过空闲空间的阈值自动触发。回收废弃页或过时的已提交的页。被标记为废弃的页被回收时，其所属的事务还未提交的话，该事务的事务表项的NPage属性要减一。

回收废弃页不足为道，此处关注一下回收过时的已提交页，可能存在两种情况。

- 需要被回收的页是该事务的最后一个页P，即其事务状态标志为TRUE，则在回收前，通过其Link指针找到前一个页P1，然后置P1的状态标志为TRUE，再回收P，保证提交的事务的影子页链中至少存在一个页的事务状态为TRUE
- 需要被回收页是该事务的影子页链中间的页P，则在回收前，需要将P的前一个页P1的状态置为TRUE，这样回收P后，会出现两条影子页链，此时视这两条链属于两个事务，保证这两个事务的影子页链中都至少有一个页的事务状态为TRUE。

#### Recovery







