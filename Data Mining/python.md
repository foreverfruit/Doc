[TOC]

## Python基础

内置函数type()，查询变量类型

print的另一个用法，print后跟多个输出，以逗号分隔。

序列有两种：tuple（定值表； 也有翻译为元组） 和 list (表)。tuple和list的主要区别在于，一旦建立，tuple的各个元素不可再变更，而list的各个元素可以再变更。序列元素的下标从0开始，元素类型可以不同。

字符串是一种特殊的元组。

print(5 in [1,3,5]）       # 5是list [1,3,5]的一个元素，打印布尔值，是否存在，这里为True

print(not True )            # not, “非”运算， 取反

range(x)功能是新建一个表。这个表的元素都是整数，从0开始，下一个元素比前一个大1， 直到函数中所写的上限 （不包括该上限本身），还可以以步进方式创建表。

Python的函数允许不返回值，也就是不用return。默认返回的是None，函数可以返回多个值，逗号隔开，实际返回的是一个tuple元组对象

**参数传递**：对于基本数据类型的变量，变量传递给函数后，函数会在内存中复制一个新的变量，从而不影响原来的变量（我们称此为值传递）。但是对于复杂对象（如三种序列对象）来说，传递给函数的是一个指针，指针指向对象在内存中的位置，在函数中对对象的操作将在原有内存中进行，从而影响原有变量。 （我们称此为指针传递）

定义类的函数时，方法的第一个参数必须是self，无论是否用到，self只限内部使用，不用传参。

子类继承父类的所有属性，包括变量属性和方法属性。

Python有一些特殊方法。Python会特殊的对待它们。特殊方法的特点是名字前后有两个下划线，如类的构造方法。

**python对象属性和类属性，访问修改及内存模型中的大坑需要注意，和其他语言不太一样。**

dir()用来查询一个类或者对象所有属性。

运算符是特殊方法，在类内部定义了该运算符的方法。

---

## Python进阶

词典的元素没有顺序。你不能通过下标引用元素。词典是通过键来引用。

在词典中增添一个新元素的方法：引用一个新的键，并赋予它对应的值。而表list添加元素是append，而元组tuple不能增删改元素。

删除词典元素用del，如del(dict['key1'])

文本文件读写：open(filename,mode)构建文件对象,然后调用file对象操作文件读写。

在Python中，一个.py文件就构成一个模块。通过模块，你可以调用其它文件中的程序。

可以将功能相似的模块放在同一个文件夹中，构成一个模块包。该文件夹中必须包含一个\_\_init\_\_.py的文件，提醒Python，该文件夹为一个模块包。__init__.py可以是一个空文件。

python的函数调用参数传递有几种方式：参数列表的参数位置传递，关键字传递（形参名=实参），也可以混用，但是根据位置传递的参数要正确得放在参数列表前面。

包裹：变长参数，python的变长参数定义时用*name的方式告诉函数这是变长参数，包裹成一个tuple元组。若需要变长的键值对作为参数，即包裹的参数是字典，需要以**name的方式通知函数。

解包裹：在调用函数的时候，需要传入的是固定的几个参数，但是现在数据是一个元组或者字典，则可以直接用解包的方式将该集合元素打散分别作为对应参数传入函数。方式同包裹一样，元组用*，字典用**。

**参数列表顺序**：先位置，再关键字，再包裹位置，再包裹关键字。

enumerate()函数，可以在每次循环中同时得到下标和元素。range函数只能得到元素值，不会得到index。

如果你多个等长的序列，然后想要每次循环时从各个序列分别取出一个元素，可以利用zip()方便地实现，就是依次取矩阵的第一列、第二列……，取出的元素组成一个元组。

循环对象和for循环调用之间还有一个中间层，就是要将循环对象转换成迭代器(iterator)。循环只能针对可循环的对象实施，他们都有next方法

**生成器**：generator，用于自定义循环对象。

理解生成器表达式(Generator Expression):

```python
G = (x for x in range(4))
```

表推导：list comprehension，快速生成表。与生成器类似，利用的是循环对象。

```python
L = [x**2 for x in range(10)] # L=[0,1,4,9,16,25,36,49,64,81]
```

```python
xl = [1,3,5]
yl = [9,12,13]
L  = [ x**2 for (x,y) in zip(xl,yl) if y > 10]
# L = [9,25]
```

函数也是一个对象，具有属性，可用dir()查询。

函数可以作为一个对象，进行参数传递。python函数参数，数值类型是值传递，其他都是引用传递。

lambda生成一个函数对象

```python
func = lambda x,y: x + y # 这里lambda语句生成一个函数对象，引用赋值给func
```

map(func,collection)函数，作用是将函数func依次作用于collection的每个元素，这个函数func可以是lambda语句生成的函数对象。map返回的是一个结果集的循环对象，可用list()函数将其转为list。

```python
re = map((lambda x,y: x+y),[1,2,3],[6,7,9]) 
# map()将每次从两个表中分别取出一个元素，带入lambda所定义的函数
```

filter(func,[10,56,101,500])，filter函数的第一个参数也是一个函数对象。它也是将作为参数的函数对象作用于多个元素。如果函数对象返回的是True，则该次的元素被储存于返回的表中，filter返回的不是表，而是循环对象（同样需要list函数转换）。

reduce函数的第一个参数也是函数，但有一个要求，就是这个函数自身能接收两个参数。reduce可以累进地将函数作用于各个参数。

```python
reduce((lambda x,y: x+y),[1,2,5,7,9]) 
# 相当于(((1+2)+5)+7)+9
# 使用reduce需要导入 functools包
```

异常代码块的执行：try->异常->except->finally，try->无异常->else->finally。也可手动抛出异常，raise 异常对象

对象存储模型：列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。我们之前学的元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object.

```python
def f(x):
    x[0] = 100
    print(x)

a = [1,2,3]
f(a)
print(a)
# 输出[100,2,3]
# 这里a和x指向同一个对象，但是list对象是可变数据对象，通过引用元素改变了x[0]的值
```

---

## Python深入

Python的运算符是通过调用对象的特殊方法实现的。如+：

```python
'abc' + 'xyz'               # 连接字符串
'abc'.__add__('xyz')        # 实际执行这个特殊方法
```

许多内置函数也都是调用对象的特殊方法，如：

```python
len([1,2,3])      # 返回表中元素的总数
[1,2,3].__len__() # 实际调用
```

在Python中，函数也是一种对象。实际上，任何一个有__call__()特殊方法的对象都被当作是函数。

对于内置的对象来说(比如整数、表、字符串等)，它们所需要的特殊方法都已经在Python中准备好了。而用户自己定义的对象也可以通过增加特殊方法，来实现自定义的语法。

任何定义了\_\_enter\_\_()和\_\_exit\_\_()方法的对象都可以用于上下文管理器。使用上下文管理器以 (with...as...)代码块的形式

```python
with open("new.txt", "w") as f:
    print(f.closed)
    f.write("Hello World!")
print(f.closed) # 到这里，在上面的缩进代码块中f已经调用了它的__exit__函数关闭了
# __exit__(self,exc_type,exc_value,traceback):后是三个参数用于异常处理
```

Python一切皆对象(object)，每个对象都可能有多个属性(attribute)。Python的属性有一套统一的管理方案。

可以利用__class__属性找到对象的类，然后调用类的__base__属性来查询父类

property特性使用内置函数property()来创建。property()最多可以加载四个参数。前三个参数为函数，分别用于处理查询特性、修改特性、删除特性。最后一个参数为特性的文档，可以为一个字符串，起说明作用。